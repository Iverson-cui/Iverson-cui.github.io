---
title: pa1知识点记录
tags:
  - 一生一芯
date: 2025-04-20
---
# 网络连接bug
现象为：浏览器上不去网，ping baidu.com显示name resolution出现问题。
解决方法：sudo dhcpcd
dhcpcd意思是DHCP client daemon，DHCP客户端守护进程。它是一个用于自动配置网络接口的工具，通常用于获取IP地址和其他网络设置。dhcpcd会向DHCP服务器发送请求，并根据服务器的响应配置网络接口。
这里可能是连接出现了问题，运行dhcpcd重新配置一下，之后就好了。
# makefile include
在fceux里面，readme写的是make ARCH=native run mainargs=mario来运行。意思是设置变量ARCH值为native，执行target run，设置变量mainargs值为Mario。注意这个makefile里有include语句，包含了另外一个makefile。正是这另外一个里面有run这个target。
# SDL
在使用模拟器的时候，模拟器是通过SDL这个lib来获取的我们的键盘和鼠标信息。SDL simple directmedia layer，是一个库，可以have access to input devices，比如键盘，鼠标等等。
这就是为什么如果键盘捕获出了问题，讲义上说需要搜索SDL keystroke。

#ccache
这是一个cpp compiler cache软件，会在编译之后保存一份编译结果。如果下次编译，源文件没有更改，就直接使用上次的编译结果。这样速度会大大提升。
提升编译速度的另一个方法：调用多个cpu线程。先用lscpu查看有几个，之后在make命令后面加-j?，？是你想调用的线程数。

上面这两个结合起来会大大提升编译速度。
# NEMU
[这里的](https://ysyx.oscc.cc/docs/ics-pa/1.1.html#nemu%E6%98%AF%E4%BB%80%E4%B9%88)图片很好的展示了NEMU的作用：
所有的应用程序运行的时候，都是底层硬件，中间层操作系统，上层软件。对于操作系统来说，上层是什么应用程序都一样，就算是模拟器也和helloworld一样。而模拟器模拟出来的硬件，可以作为别的应用程序的底层。所以NEMU本质上就是个模拟器，模拟了硬件的工作，但又不是真正的硬件。就好像支付宝模拟了ATM的工作，但并不是实体真正的ATM。
在NEMU中, 每一个硬件部件都由一个程序相关的数据对象来模拟, 例如变量, 数组, 结构体等; 而对这些部件的操作则通过对相应数据对象的操作来模拟. 例如NEMU中使用数组来模拟内存, 那么对这个数组进行读写则相当于对内存进行读写.

# ISA instruction set architecture
大部分课本上都会有类似"ISA是软件和硬件之间的接口"这种诠释, 但对于还不了解软件和硬件之间如何协同工作的你来说, "接口"这个词还是太抽象了.

为了理解ISA, 我们可以用现实生活中的例子来比喻: 螺钉和螺母是生活中两种常见的物品, 它们一般需要配对来使用. 给定一个螺钉, 那就要找到一个符合相同尺寸规范的螺母才能配合使用, 反之亦然.

在计算机世界中也是类似的: 不同架构的计算机(或者说硬件)好比不同尺寸的螺钉, 不同架构的程序(或者说软件)就相当于是不同尺寸的螺母, 如果一个程序要在特定架构的计算机上运行, 那么这个程序和计算机就必须是符合同一套规范才行.

因此, ISA的本质就是类似这样的规范. 所以ISA的存在形式既不是硬件电路, 也不是软件代码, 而是一本规范手册.

和螺钉螺母的生产过程类似, 计算机硬件是按照ISA规范手册构造出来的, 而程序也是按照ISA规范手册编写(或生成)出来的, 至于ISA规范里面都有哪些内容, 我们应该如何构造一个符合规范的计算机, 程序应该如何遵守这些规范来在计算机上运行, 回答这些问题正是做PA的一个目标.
# 开天辟地的篇章
## 最简单的计算机
需要满足的条件是：
- 结构上, TRM有存储器, 有PC, 有寄存器, 有加法器
- 工作方式上, TRM不断地重复以下过程: 从PC指示的存储器位置取出指令, 执行指令, 然后更新PC

所以，计算机其实就是状态机。其中的组合逻辑部件为加法器，时序逻辑部件为存储器 PC 寄存器。每个状态下，根据PC 寄存器和存储器的当前值，进行运算。运算完后更新PC 寄存器和存储器的值，也就进入了下一个状态。

所以状态机的状态由PC 寄存器和存储器的当前值来决定。比如有4个8位的寄存器, 一个4位PC, 以及一段16字节的内存(也就是存储器), 那么这个计算机可以表示比特总数为B = 4*8 + 4 + 16*8 = 164, 因此这个计算机总共可以有N = 2^B = 2^164种不同的状态. 假设这个在这个计算机中, 所有指令的行为都是确定的, 那么给定N个状态中的任意一个, 其转移之后的新状态也是唯一确定的.

当程序运行在计算机上的时候，程序的开始其实就是在这2^164 的状态中选定一个作为初始状态，接着往下走到下一个状态。。。所以本质上，程序的运行也是状态机，且其状态是2^164 个状态的这个大状态机的子集。

对于1+2+。。。+100的程序，状态图为：
(0,x,x)->(1,0,x)->(2,0,0)->(3,0,1)->(4,1,1)->(2,1,1)->(3,1,2)->(4,3,2)->(2,3,2)->(3,3,3)->(4,6,3)->(2,6,3)->...->(4,1+...+99,99)->(2,1+...+99,99)->(3,1+...+99,100)->(4,1+...+100,100)->(5,1+...+100,100)->(5,1+...+100,100)->...
# RTFSC
## getopt_long
getopt_long是cpp的一个函数，作用是处理command line argument。他是getopt的拓展，不同之处在于可以处理长的option和短的option。
函数的function prototype是这样的：
``` C
int getopt_long(int argc, char * const argv[],
                const char *optstring,
                const struct option *longopts, int *longindex);
```

要想使用这个函数，首先需要调用对应的getopt.h库。其次，你需要定义一个data structure叫struct option。具体来说，在getopt.h文件里定义的结构是这样的：
``` C
struct option {
    const char *name;    /* Option name */
    int has_arg;         /* Argument requirement */
    int *flag;           /* Flag variable address */
    int val;             /* Return value or flag value */
};
```
这是一个元素的四个entry。如果是多个元素，则需要定义一个array：
``` C
struct option long_options[] = {
    {"verbose", no_argument,       NULL, 'v'},
    {"output",  required_argument, NULL, 'o'},
    {"lines",   required_argument, NULL, 'n'},
    {0, 0, 0, 0}
};
```
第二个entry意思是这个flag是否接受参数。no_argument就是不接受 required_argument就是接受 optional_argument就是可选。
The flag and val fields interact in an important way:

If flag is NULL, getopt_long returns val
If flag is not NULL, getopt_long stores val at the address pointed to by flag and returns 0

同时，getopt_long这个函数还有许多附加的global variable来存储状态。这些variable分别是：
- optind: Index of the next element in argv to be processed (starts at 1)
- optarg: Points to the argument for the current option (if any)
- opterr: Controls error messaging (1 = print errors, 0 = silent)
- optopt: Stores the unknown option character when errors occur
比如有一个option是--file=document.txt，则optarg指针指向“document.txt"。对于short option也是一样会存储这个option对应的argument。

下面是一个例子：
``` C
// Option definition
static struct option long_options[] = {
    {"verbose", no_argument,       NULL, 'v'},
    {"output",  required_argument, NULL, 'o'},
    {"lines",   required_argument, NULL, 'n'},
    {0, 0, 0, 0}
};

// In a loop
while ((c = getopt_long(argc, argv, "vo:n:", long_options, NULL)) != -1) {
    // ...process options...
}
```

根据这个例子，我们先解释getopt函数的input argument都是什么意思：
argc和argv就是命令行的参数。
由于是long版本，所以传入的参数可能有short option和long option。第三个argument是一个字符串。"vo:n"，这个字符串规定了所有short option的取值和参数情况。
  This string defines all the valid short options and their argument requirements.
  How it's used:

  Each character in the string represents a recognized short option.
  A character followed by a colon (":\") means that option requires an argument.
  Two colons (":\:") means the option takes an optional argument.
  A leading "+" or "-" changes how non-option arguments are handled.
  Example: "ab:c::" would define:

  -a as an option with no argument
  -b as an option requiring an argument
  -c as an option with an optional argument

第四个变量const struct option *longopts规定了valid long option的取值。

How it's used:

The function searches this array for a match when it encounters a long option (starting with "--").
Each entry in the array defines one long option's name, argument requirement, and behavior.
The array must end with an entry filled with zeros.
The function compares the option on the command line with each name in this array sequentially.

当碰到一个long option的时候，会在longopts里面搜索name是对应option的entry。同时查看这个条目对应的has_arg field来决定他是否expect an argument。

第五个参数：
This optional parameter returns the index of the matched long option in the longopts array.
如果调用函数的时候写成的是NULL，则说明不要这个功能 也可以。如果真的给出了一个指针，则long option匹配到了table中的第几个就更改指针指向的变量的值为几。

这个函数的返回值对应的具体情况是：
The return value itself is also important:

- Returns the val field of the matched long option if flag is NULL
- Returns 0 if the option sets a flag (non-NULL flag pointer)
- Returns the option character for short options
- Returns -1 when all options have been processed
- Returns '?' for unrecognized options or missing required arguments
- Returns ':' for missing required arguments if optstring starts with ':'

注意，对于long option而言，返回什么取决于table中定义的flag。

在实际应用的时候，都是套进while循环里，因为参数有很多个，with the update of optind，循环能处理所有参数，直到其==-1，也就是所有参数处理完的情况下。

当getopt_long函数被调用的时候，首先它会检查optind位置的参数（optind已被默认设置为1）。如果当前的 argument starts with "-" then it is regarded as a short option. If it starts with "--" then as a long option. Otherwise it is a non-option argument. 
After checking arguments at optind, it updates optind to point to the next argument.

下面讨论面对不同的option的情况：
When getopt_long encounters a short option:

1. It looks for the option character in the optstring
2. If the character is followed by a colon in optstring, it expects an argument
3. This argument can be:
   - The rest of the same argv element (like -avalue)
   - The next argv element (like -a value)


4. If an argument is required but missing, it returns '?' (error)

For long options, the process is more complex:

1. It searches through the longopts array for a matching name
2. For exact matches, it uses that option
2. For partial matches, it uses the option only if it's unambiguous (no other option starts with the same prefix)
3. Arguments can be provided as:

     - --option=value (with equals sign)
    - --option value (next argv element)


5. The handling depends on the has_arg field in the corresponding struct option

### 真实的例子
``` C
#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>
#include <stdbool.h>

void print_usage() {
    printf("Usage: fileprocessor [options] file...\n");
    printf("Options:\n");
    printf("  -h, --help                 Display this help message\n");
    printf("  -v, --verbose              Enable verbose output\n");
    printf("  -o, --output=FILE          Write output to FILE\n");
    printf("  -n, --lines=NUM            Process only NUM lines\n");
    printf("  -i, --ignore-case          Ignore case distinctions\n");
}

int main(int argc, char *argv[]) {
    // Default settings
    bool verbose = false;
    bool ignore_case = false;
    char *output_file = NULL;
    int num_lines = -1; // -1 means all lines
    
    int c;
    
    static struct option long_options[] = {
        {"help",        no_argument,       NULL, 'h'},
        {"verbose",     no_argument,       NULL, 'v'},
        {"output",      required_argument, NULL, 'o'},
        {"lines",       required_argument, NULL, 'n'},
        {"ignore-case", no_argument,       NULL, 'i'},
        {0, 0, 0, 0}
    };
    
    while ((c = getopt_long(argc, argv, "hvo:n:i", long_options, NULL)) != -1) {
        switch (c) {
            case 'h':
                print_usage();
                return 0;
                
            case 'v':
                verbose = true;
                break;
                
            case 'o':
                output_file = optarg;
                break;
                
            case 'n':
                num_lines = atoi(optarg);
                if (num_lines <= 0) {
                    fprintf(stderr, "Error: Number of lines must be positive\n");
                    return 1;
                }
                break;
                
            case 'i':
                ignore_case = true;
                break;
                
            case '?':
                return 1;
                
            default:
                abort();
        }
    }
    
    // Print the settings (for demonstration)
    printf("Settings:\n");
    printf("  Verbose: %s\n", verbose ? "yes" : "no");
    printf("  Ignore case: %s\n", ignore_case ? "yes" : "no");
    printf("  Output file: %s\n", output_file ? output_file : "standard output");
    printf("  Number of lines: %d\n", num_lines == -1 ? -1 : num_lines);
    
    // Process files
    if (optind < argc) {
        printf("Files to process:\n");
        while (optind < argc)
            printf("  %s\n", argv[optind++]);
    } else {
        printf("No input files specified\n");
    }
    
    return 0;
}
```
从中可以看出：
- getopt_long的作用只是提取出输入各个argument，还需要一个switch case语句来将每种argument和对应的处理情况相连接。比如我想开启verbose模式，getopt_long只能辨别出我输入的是-v，真正实现“如果输入-v就是开启verbose模式“的代码是case里面做到的。
- 有的option有简写模式，比如--verbose也可以写成-v。前者根据table判断，返回v，后者直接不进table根据函数第三个输入argument判断，也返回v。所以2个输入在处理的时候进入的是同一个case，因此输入--verbose和-v效果是一样的。
- 如果跳出了循环，不一定就是到了最后一个argv。这里还有optind和argc的判断。除了option，其余全是传入的argument。比如gcc就是先设置一堆flags，最后传入的是需要编译的文件。
``` C
#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>

int main(int argc, char *argv[]) {
    int verbose_flag = 0;
    int c;
    
    static struct option long_options[] = {
        {"verbose", no_argument,       &verbose_flag, 1},
        {"brief",   no_argument,       &verbose_flag, 0},
        {"add",     required_argument, NULL,         'a'},
        {"file",    required_argument, NULL,         'f'},
        {0, 0, 0, 0}  // End of array marker
    };
    
    int option_index = 0;
    
    while ((c = getopt_long(argc, argv, "a:f:", long_options, &option_index)) != -1) {
        switch (c) {
            case 0:
                // If flag is set, we don't need to do anything here
                printf("Option %s", long_options[option_index].name);
                if (optarg)
                    printf(" with arg %s", optarg);
                printf("\n");
                break;
                
            case 'a':
                printf("Option -a with value '%s'\n", optarg);
                break;
                
            case 'f':
                printf("Option -f with value '%s'\n", optarg);
                break;
                
            case '?':
                // Error handling - getopt_long already printed error message
                break;
                
            default:
                abort();
        }
    }
    
    if (verbose_flag)
        printf("Verbose flag is set\n");
        
    // Process any remaining arguments (not options)
    if (optind < argc) {
        printf("Non-option arguments: ");
        while (optind < argc)
            printf("%s ", argv[optind++]);
        printf("\n");
    }
    
    return 0;
}
```
这里主要想强调当table里面的flag不是NULL的情况时（又叫作flag option。flag option本身属于long option）。这里verbose和brief就是这样的情况。函数碰到这2个option，返回值都是0.但是这两个option会将其table的最后一个entry的值写入第三个entry指向的那个int。可以这样理解：将下面的switch case里的对于单个变量的处理移到了上面。这样，case 0对应的就是所有这些option，因为已经处理完了，就不需要在case里额外处理了。

对于flag option，由于都返回的是0，如果想要额外区分，就可以使用函数的第五个参数longindex。对于许多个table中的entry返回值都是同一个字母的时候也可以用到这个进行更细粒度的处理。
## 源代码学习记录
### macro的各种处理
以下的代码片段均选自nemu的macro.h，体现了functional-programming-like macro (X-macro)的思想，设计十分精巧。
``` C
#ifndef __MACRO_H__
#define __MACRO_H__

#include <string.h>

// macro stringizing
#define str_temp(x) #x
#define str(x) str_temp(x)

// strlen() for string constant
#define STRLEN(CONST_STR) (sizeof(CONST_STR) - 1)

// calculate the length of an array
#define ARRLEN(arr) (int)(sizeof(arr) / sizeof(arr[0]))
```
- 头文件里也能include别的库文件，可以将宏转化为函数
- 多个主文件引用同一个头文件的情况别忘了给头文件加ifdef macro，避免重复定义
- 2 level approach：在cpp里，macro展开是有顺序的：先内后外，先展开argument在substitute。带有#符号的不展开。#的意思是将后面的东西转化为字符串。比如我先#define VERSION 1.0，之后如果直接str_temp(VERSION)，我不会得到"1.0"，只会得到"VERSION"。但是通过这里提到的双层展开的方法，str(VERSION)->str(1.0)->str_temp(1.0)->"1.0"。

``` C
// macro concatenation
#define concat_temp(x, y) x##y
#define concat(x, y) concat_temp(x, y)
```
- 这里的双层concatenation也是这个原理。如果传入的x和y是macro，会先expand macro再concatenate。

``` C
#define CHOOSE2nd(a, b, ...) b
#define MUX_WITH_COMMA(contain_comma, a, b) CHOOSE2nd(contain_comma a, b)
#define MUX_MACRO_PROPERTY(p, macro, a, b) MUX_WITH_COMMA(concat(p, macro), a, b)
```
- CHOOSE2nd一直选择以，分割的第二个元素
- 注意这里的MUX_WITH_COMMA定义的是CHOOSE2nd(contain_comma a,b)，其中contain_comma和a合成了一个元素，所以如果如果contain_comma这个宏没有expand成一个有comma的元素，其和a会被看成一个元素 输出b。contain_comma如果结尾确实是个comma，则会输出a。
- MUX_MACRO_PROPERTY输入四个元素，会将p和macro，第一二个元素先结合起来，再输入到MUX_WITH_COMMA里面。

``` C
// define placeholders for some property
#define __P_DEF_0 X,
#define __P_DEF_1 X,
#define __P_ONE_1 X,
#define __P_ZERO_0 X,
// define some selection functions based on the properties of BOOLEAN macro
#define MUXDEF(macro, X, Y) MUX_MACRO_PROPERTY(__P_DEF_, macro, X, Y)
#define MUXNDEF(macro, X, Y) MUX_MACRO_PROPERTY(__P_DEF_, macro, Y, X)
#define MUXONE(macro, X, Y) MUX_MACRO_PROPERTY(__P_ONE_, macro, X, Y)
#define MUXZERO(macro, X, Y) MUX_MACRO_PROPERTY(__P_ZERO_, macro, X, Y)

```
- 这里可以和上面打配合。特别注意，这里的_P_DEF_0等四个变量被赋值给了"X,"，本来#define不需要加","，这里是故意加给值的。
- 以MUXDEF为例子，如果macro被拓展为0，则MUX_MACRO_PROPERTY(__P_DEF_,macro,1,0)->MUX_MACRO_PROPERTY(__P_DEF_,0,1,0)->MUX_WITH_COMMA(concat(__P_DEF_, 0), 1, 0)->MUX_WITH_COMMA(__P_DEF_0, 1, 0)->CHOOSE2nd(__P_DEF_0 1,0)->CHOOSE2nd(X,1,0)，因此输出1。如果macro被拓展为2，这是没有定义的，则MUX_MACRO_PROPERTY(__P_DEF_,macro,1,0)->MUX_MACRO_PROPERTY(__P_DEF_,2,1,0)->MUX_WITH_COMMA(concat(__P_DEF_, 2), 1, 0)->CHOOSE2nd(__P_DEF_2 1,0)，因为__P_DEF_2没被定义，__P_DEF_2 1是一整个元素，所以输出0。
- 综上，MUXDEF做的事情就是，如果__P_DEF_macro被定义了，就返回X，如果没被定义就返回Y。
``` C
// test if a boolean macro is defined
#define ISDEF(macro) MUXDEF(macro, 1, 0)
// test if a boolean macro is undefined
#define ISNDEF(macro) MUXNDEF(macro, 1, 0)
// test if a boolean macro is defined to 1
#define ISONE(macro) MUXONE(macro, 1, 0)
// test if a boolean macro is defined to 0
#define ISZERO(macro) MUXZERO(macro, 1, 0)
```
- 如果传入MUXDEF的macro是1或者0，则MUXDEF都输出1，即ISDEF也输出1，表明macro被定义了。ISNDEF相反。ISONE中的macro只能是1，否则ISONE就是0，ISZERO相反。

``` C
// test if a macro of ANY type is defined
// NOTE1: it ONLY works inside a function, since it calls `strcmp()`
// NOTE2: macros defined to themselves (#define A A)  will get wrong results
#define isdef(macro) (strcmp("" #macro, "" str(macro)) != 0)
```
- 在strcmp里，如果macro被定义了，第一个参数就是macro，第二个参数，由上文，是macro被替换后的字符串。两者如果不相等，isdef返回1，说明被定义。
- 在cpp里，static变量和global variable，macro，array size等等必须是在compile time就确定的参数，但是isdef调用了函数，只有runtime才能有值，所以将isdef的结果赋值给这些的写法是错误的。
- 之所以写成“” #macro的原因：Handling Empty Macros: If macro is defined as empty, then #macro becomes "". The empty string concatenation ensures consistent behavior.
Protection Against String Literal Bugs: Some older compilers had edge cases with the # operator directly. The empty string concatenation provides defensive coding against potential compiler quirks.
Consistent String Type: Ensures both sides of the comparison are definitely string literals of the same type.

``` C
// simplification for conditional compilation
#define __IGNORE(...)
#define __KEEP(...) __VA_ARGS__
// keep the code if a boolean macro is defined
#define IFDEF(macro, ...) MUXDEF(macro, __KEEP, __IGNORE)(__VA_ARGS__)
// keep the code if a boolean macro is undefined
#define IFNDEF(macro, ...) MUXNDEF(macro, __KEEP, __IGNORE)(__VA_ARGS__)
// keep the code if a boolean macro is defined to 1
#define IFONE(macro, ...) MUXONE(macro, __KEEP, __IGNORE)(__VA_ARGS__)
// keep the code if a boolean macro is defined to 0
#define IFZERO(macro, ...) MUXZERO(macro, __KEEP, __IGNORE)(__VA_ARGS__)
```
- __IGNORE的意思是接受一堆参数但是expand to nothing，也就是忽视后面传入的所有参数。
- __KEEP接受所有参数，并且原样不变。__VA_ARGS\_\_会被自动expand到所有传入的参数。
- 和下面的4个打配合，就是：如果传入IFDEF的macro被expand为0或者1，就保留后面的所有东西，如果macro被定义为其他或者没被定义，就啥都不保留。
- 和上面的ISDEF类似，只不过ISDEF是返回0或者1，这里是根据是否定义执行语句。

可以看下面的例子：
``` C
#define DEBUG 1

void function(void) {
    IFDEF(DEBUG,
        printf("Debug info: counter=%d\n", counter);
        log_state();
    )
    
    // Normal code continues here
    process_data();
}
```
中间的代码在被compiler处理后变成了：
``` C
printf("Debug info: counter=%d\n", counter);
log_state();
```
就是简单的调用函数。
``` C
// functional-programming-like macro (X-macro)
// apply the function `f` to each element in the container `c`
// NOTE1: `c` should be defined as a list like:
//   f(a0) f(a1) f(a2) ...
// NOTE2: each element in the container can be a tuple
#define MAP(c, f) c(f)
```
- 在实际使用过程中，通常先#define c(f)。比如：
``` C
// Example usage:
#define LIST_OF_REGISTERS(f) f(r0) f(r1) f(r2) f(r3)
// Apply a print function to each register
MAP(LIST_OF_REGISTERS, print_reg)
// Expands to: print_reg(r0) print_reg(r1) print_reg(r2) print_reg(r3)
```

``` C
#define PG_ALIGN __attribute((aligned(4096)))
```
- 这句涉及到了一个gcc编译器的extension，即__attribute（后面加不加__都可以，具体区别用时再查）。attribute在使用的时候一般都是double paranthesis syntax。里面的aligned（4096）意思是地址总是和4096是对齐的，因为系统的page size就是4096.
- 在使用的时候 直接将PG_ALIGN加在变量的前面，就是给对应变量添加这个性质的意思.

``` C
#if !defined(likely)
#define likely(cond) __builtin_expect(cond, 1)
#define unlikely(cond) __builtin_expect(cond, 0)
#endif

// for AM IOE
#define io_read(reg) \
  ({ reg##_T __io_param; \
    ioe_read(reg, &__io_param); \
    __io_param; })

#define io_write(reg, ...) \
  ({ reg##_T __io_param = (reg##_T) { __VA_ARGS__ }; \
    ioe_write(reg, &__io_param); })

#endif
```
- 涉及到了CPU branch和虚拟机IO的一些宏，可以在需要的时候反过来查询。
- __builtin_expect是gcc的primitive。