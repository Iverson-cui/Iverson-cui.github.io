---
title: pa2知识点记录
tags:
  - 一生一芯
date: 2025-05-07
---
# 不停计算的机器
计算机就是状态机。计算机中所有寄存器，memory的值决定了当前的状态和以后的状态。寄存器和memory的总容量决定了状态机的总状态数。程序的运行就等效于状态机在各个状态之间来回切换。
cpu运行指令的流程是fetch decode execute update，取出指令，解码，执行，更新pc也就是下一个指令的地址。
在pa2中的模拟器中，拿到一个instruction之后，是这样执行其具体指令的：首先使用union数据结构来解读分割这个instruction的各个部分：
``` C
typedef union {
  struct { uint8_t rs : 2, rt : 2, op : 4; } rtype;
  struct { uint8_t addr : 4      , op : 4; } mtype;
  uint8_t inst;
} inst_t;
```
union的各个元素共同占有同一块空间。所以这8 bits有三种解读的方法：整体当作inst，当作rtype来解读和当作mtype来解读。可以通过inst_t.rtype.rs或inst_t.mtype.addr来获取这8个bits中的某个切片。
不管是mtype还是rtype都是最后四位作为opcode。所以，模拟器通过查看opcode的四位，用switch case语句，不同的4位组合对应不同的命令，然后对addr或rs rt中的数据进行运算，这样就实现了执行机器代码的效果。
# RTFM
[这里](https://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/risccisc/index.html)有一篇关于risc和cisc对比的文章。我的理解是，cisc是更粗粒度的执行指令，更笨重，但是单个指令做很多事，而risc是细粒度的，能带来更多的优化，但是很繁琐复杂。

对于涉及到的big endian和little endian的问题，我个人的理解是：如果你当前的机器是小端的，编译器也知道，会自动将你的代码处理为小端，同时会把变量存储为小端的格式；如果你的机器是大端的也是同理。但是如果直接将小端编译完成的机器码迁移到大端机就会出问题。举个例子，int m=0h1234，在小端机的机器码里变量被存储为3412，大端机里被存储为1234，但是小端机的编译器在解释3412的时候也会按照小端机的标准来，将其解读为1234，所以在同一个类型的机器上不会出问题。

指令本身就是32位，如果immediate也是32位，则：To create larger constants, use a load upper immediate instruction (lui) followed by an add immediate instruction (addi)。将对这个immediate的处理拆成2个指令，分开去处理。

静态指令和动态指令：dynamic next PC和static next PC。
在程序分析领域中, 静态指令是指程序代码中的指令, 动态指令是指程序运行过程中的指令. 例如对于以下指令序列
100: jmp 102
101: add
102: xor
jmp指令的下一条静态指令是add指令, 而下一条动态指令则是xor指令。
由此可以看出动态指令才是真正的下一个指令。

可以查看gcc -E这个flag，作用就是对源文件进行文本替换，这样可以方便我们查看宏和头文件等等展开后的具体信息。

接下来简单记录一下一个指令在nemu中执行的流程：
cpu_exec->execute->exec_once->isa_exec_once
在这个函数里，就2行代码：

s->isa.inst = inst_fetch(&s->snpc, 4);

return decode_exec(s);

在这个函数里完成了fetch decode execute的循环。inst_fetch是取值，具体来说就是先取对应地址处的指令，再根据指令的长度更新snpc静态地址。取完的地址存储在Decode *s的isa.inst里面。之后调用decode exec函数。具体来说，其核心代码是调用INSTPAT这个宏，宏里对每个instr的字符都进行了macro这个宏的处理。公有的mask和key的值根据不断调用的macro宏而发生变化，在最后将当前指令匹配到某一个现有的支持的指令上。确定了指令，还要确定operand，是通过decode_operand这个命令来根据指令的类型将operand提取出来保存在对应的位置，因为有的指令只有imm，rd，有的却有rd rs1 rs2，并且不同指令imm的编码方式也不同，所以需要定义rs1，rs2，不同类型指令imm的提取宏（函数），然后根据指令类型，分别调用对应的宏（函数）即可。提取完后的结果都存储在相应指针里，最后根据指令类型对相应的寄存器值或memory值执行相关的操作，进行更改即可。
执行完指令后，将dnpc赋值给pc。如果不是jump等语句，dnpc=snpc=pc+4，如果是的话，dnpc已经被更改为对应的目标地址。

这里有几个c语言的语法需要注意：
1. 在定义一个macro的时候，在每一行的末尾使用到了\，这是因为：macro的定义默认只在当前行。如果将macro拓展到很多行，需要使用\，可以理解为续行，认为这行没有结束。\一直到最后一行。这样写还有一个特点就是无法加//注释，这样后面的所有都被认为是注释。解决措施是用block comment /* */。
另外的方法就是#define SAFER_MACRO(x) do {  
    statement1;  
    statement2;  
} while(0)，将其套到do while(0)里。在nemu的代码中很多处都是这样。

1. 这里还涉及到了goto+labels的使用。goto finish和下面的finish：打配合，让代码跳转到某个地方。

2. #define是定义宏，但是#undef意思是取消定义。在这个函数里，只有2句语句被正常运行，macro64（0）和Panic，其余都是定义跳转等等。macro64之后马上就取消了定义，意思就是在这之后macro就没法再使用了，会被认为没定义这个macro。


在运行第一个C程序的时候我们要注意，不同的操作系统不同的CPU架构，其上所含的gcc是不同的。比如苹果就是Unix系统加arm架构，windows就是x86架构加windows系统。我们要编译一个测试代码，编译成riscv的指令集运行，则如果调用本机的gcc，会使得编译出来的是arm指令集。这时候需要交叉编译，
apt-get install g++-riscv64-linux-gnu binutils-riscv64-linux-gnu
g++-riscv64-linux-gnu意思就是riscv64指令集 Linux系统使用的gcc，编译出来的二进制就能直接用了。如果在做nemu的时候选择的是x86指令集架构，则windows机器本机的x86就可以生成可用的机器代码。

如果指令没被定义，将会转到inv宏，这个宏里调用了invalid_inst函数，打印输出信息。

接下来开始添加新的指令到nemu中。在查阅手册的时候，有这些知识点：
unprivileged registers意思是运行在所有mode的命令都能access的regs。RISC-V有三种模式，machine mode supervisor mode和user mode，优先级逐层递减。unprivileged registers是运行在user mode都能获取到的寄存器。比如general purpose registers x0-x31.

手册p23有不同指令类型的instruction format,还有下面的immediate格式，图片的意思是对于一个32位的immediate，其各个位的数据都从32位指令的哪里取得。比如在I type immediate里面，前20位都取指令的最后一位的数（sign extend）。

在手册里，只是说了unprivileged regs有32个，第一个是0，并没有说这些寄存器分别用来干什么，这是由机器决定的。对于我们的nemu，执行指令的时候，指令里的寄存器也是以次序为标记的。所以我们需要先明确对于我们的nemu，寄存器和次序的关系：
"$0", "ra", "sp", "gp", "tp", "t0", "t1", "t2",
    "s0", "s1", "a0", "a1", "a2", "a3", "a4", "a5",
    "a6", "a7", "s2", "s3", "s4", "s5", "s6", "s7",
    "s8", "s9", "s10", "s11", "t3", "t4", "t5", "t6"


查看dummy-riscv32-nemu.txt可得这个程序需要用到的指令。注意后面写的有的是pseudo instruction，需要根据机器码来看这个指令到底在riscv manual里对应的是什么。
- p26页 addi。
- li是个pseudo-instruction，如果imm少于12位则li等效于一个addi。若其大于12位则li等效于lui+addi。这就是上文提到的32位immediate的处理方法。在dummy.c里，li指令其实就是addi，其指令代码为0x0000_0413。
- p28页jal。由于没有定义J type，我们先添加了J-Type这个类型，并为这个类型编写提取操作数的语句。提取操作数需要用到SEXT这个macro，意思是sign extend。jal本身有一个immediate和rd作为参数，其行为是将immediate+当前jal所在地址得到的值赋给PC，同时将PC+4赋给rd寄存器。这里注意，在取值完成后，我们已经将s->snpc变成了pc+4，所以赋值的时候需要让R(rd)=s->pc+4。
- 在dummy-riscv32-nemu.txt里的ret其实是jalr。翻译过来，意思是imm=0 rs1=1的jalr，意思是计算（rs1号寄存器的值的值）+imm，将其lsb赋为0，跳转到这个位置。并将rd寄存器的值赋为jalr地址+4。如果不需要记录返回值，就将rd设为x0。在这里，ret的机器码翻译过来，就是rd=0，imm=0，rs1=1，也就是跳转到ra这个寄存器里的地址处。ra的这个值恰恰是前面jal放进去的，所以这个语句是ret。
- sb和sw的区别：两者的格式都是sw rs2 imm(rs1)和sb rs2 imm(rs1)。地址的计算方法是相通的，rs1寄存器的值加imm。存储的东西不同，sw是存储整个rs2的32位数，而sb是只存储rs2 32位中的lsb。




summary: 已经支持并经过测试的指令有
- auipc
- addi
- lw
- sw
- jal
- lui



接下来我完成了lw sw和lui。我打算测试一下。查阅资料得：auipc的意思是AUIPC (add upper immediate to pc) is used to build pc-relative addresses and uses the U-type format. AUIPC forms a 32-bit offset from the U-immediate, filling in the lowest 12 bits with zeros, adds this offset to the address of the AUIPC instruction, then places the result in register rd. 将auipc指令所在的地址和一个常数相加，将结果赋值给 destination register。


关于地址的部分，可以参考pa1知识点记录的init_isa()标题。
pmem在memory/paddr.c里面已经定义好，是个size为CONFIG_MSIZE的，类型为uint8_t的array。目前里面什么都没有。
在读取指令的时候，调用的是include/cpu/ifetch.h这个文件里定义的inst_fetch这个函数，是专门从memory读取命令的函数。里面调用的vaddr_ifetch这个函数，调用了paddr_read这个函数，里面调用了pmem_read。在这之前，所有的地方的argument对应的地址都是guest memory，类似于0x8000 0004这样的。在pmem_read里，首先调用了guest_to_host这个函数。这个函数接受一个guest memory，返回一个host memory。比如接受0x8000 0004，返回对应的本机上pmem对应元素的地址。这才真正完成了地址转换，之后调用host_read函数读取地址对应的元素。这个函数很简单，有一点值得一提的是，在传入参数的时候，由于不清楚你要读取的长度是多少，函数先让addr为void \*类型，接着有一个case语句，根据情况的不同赋给addr不同类型的指针。当addr的类型被处理好了，只需要return \*addr就可以读取对应长度的数据了。这里引用一下函数的本体语句：
``` C
static inline word_t host_read(void *addr, int len) {
  switch (len) {
    case 1: return *(uint8_t  *)addr;
    case 2: return *(uint16_t *)addr;
    case 4: return *(uint32_t *)addr;
    IFDEF(CONFIG_ISA64, case 8: return *(uint64_t *)addr);
    default: MUXDEF(CONFIG_RT_CHECK, assert(0), return 0);
  }
}
```
所以，经过了层层包装，pmem_read最终接受guest memory和读取的字节长度len作为输入，返回guest memory处长度为len的数据。地址转换已经被抽象到底层无需care了。


这里可以多体会一下多层抽象的思想，如果换成我写，大概率就是用一个大函数叫read_mem，里面包含了所有的边界判断，更新pc等等操作。这里使用了多层抽象多层封装调用，每一层都有各自的目的。inst_ifetch是专门用来读取指令的函数，显然它除了读取以外还要先更新pc为pc+4。它调用的vaddr_ifetch除了调用paddr_read别的什么都没做，但是这是为了和取数据的函数进行区分。
``` C

word_t vaddr_ifetch(vaddr_t addr, int len) {
  return paddr_read(addr, len);
}

word_t vaddr_read(vaddr_t addr, int len) {
  return paddr_read(addr, len);
}
```
两个函数都是什么也没做只是调用了一个函数。所以理论上这两个函数都可以直接替换为paddr_read，但是为了区分应用场景，一个paddr_read是为了读取指令，另一个paddr_read是为了读取数据。可见为了让人读的舒服加了多少层抽象。在paddr_read里面，除了读内存，还做了边界判断，以免读的内存超过了内存的范围，在pmem_read内部，才是真正做了地址转换+读写内存的操作。所以可以看到，除了核心操作以外，每多做一件事情，就多套一层函数，方便管理。
这种思想还有很多，在nemu里，很多函数在多个文件里用不同的macro来表示，都只是为了在当前的文件里能以更readable的形式呈现出来。

说回程序本身，我又测试了lw sw的正确性。
 