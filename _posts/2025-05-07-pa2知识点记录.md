---
title: pa2知识点记录
tags:
  - 一生一芯
date: 2025-05-07
---
# 不停计算的机器
计算机就是状态机。计算机中所有寄存器，memory的值决定了当前的状态和以后的状态。寄存器和memory的总容量决定了状态机的总状态数。程序的运行就等效于状态机在各个状态之间来回切换。
cpu运行指令的流程是fetch decode execute update，取出指令，解码，执行，更新pc也就是下一个指令的地址。
在pa2中的模拟器中，拿到一个instruction之后，是这样执行其具体指令的：首先使用union数据结构来解读分割这个instruction的各个部分：
``` C
typedef union {
  struct { uint8_t rs : 2, rt : 2, op : 4; } rtype;
  struct { uint8_t addr : 4      , op : 4; } mtype;
  uint8_t inst;
} inst_t;
```
union的各个元素共同占有同一块空间。所以这8 bits有三种解读的方法：整体当作inst，当作rtype来解读和当作mtype来解读。可以通过inst_t.rtype.rs或inst_t.mtype.addr来获取这8个bits中的某个切片。
不管是mtype还是rtype都是最后四位作为opcode。所以，模拟器通过查看opcode的四位，用switch case语句，不同的4位组合对应不同的命令，然后对addr或rs rt中的数据进行运算，这样就实现了执行机器代码的效果。
# RTFM
[这里](https://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/risccisc/index.html)有一篇关于risc和cisc对比的文章。我的理解是，cisc是更粗粒度的执行指令，更笨重，但是单个指令做很多事，而risc是细粒度的，能带来更多的优化，但是很繁琐复杂。

对于涉及到的big endian和little endian的问题，我个人的理解是：如果你当前的机器是小端的，编译器也知道，会自动将你的代码处理为小端，同时会把变量存储为小端的格式；如果你的机器是大端的也是同理。但是如果直接将小端编译完成的机器码迁移到大端机就会出问题。举个例子，int m=0h1234，在小端机的机器码里变量被存储为3412，大端机里被存储为1234，但是小端机的编译器在解释3412的时候也会按照小端机的标准来，将其解读为1234，所以在同一个类型的机器上不会出问题。

指令本身就是32位，如果immediate也是32位，则：To create larger constants, use a load upper immediate instruction (lui) followed by an add immediate instruction (addi)。将对这个immediate的处理拆成2个指令，分开去处理。

静态指令和动态指令：dynamic next PC和static next PC。
在程序分析领域中, 静态指令是指程序代码中的指令, 动态指令是指程序运行过程中的指令. 例如对于以下指令序列
100: jmp 102
101: add
102: xor
jmp指令的下一条静态指令是add指令, 而下一条动态指令则是xor指令。
由此可以看出动态指令才是真正的下一个指令。

可以查看gcc -E这个flag，作用就是对源文件进行文本替换，这样可以方便我们查看宏和头文件等等展开后的具体信息。

接下来简单记录一下一个指令在nemu中执行的流程：
cpu_exec->execute->exec_once->isa_exec_once
在这个函数里，就2行代码：

s->isa.inst = inst_fetch(&s->snpc, 4);

return decode_exec(s);

在这个函数里完成了fetch decode execute的循环。inst_fetch是取值，具体来说就是先取对应地址处的指令，再根据指令的长度更新snpc静态地址。取完的地址存储在Decode *s的isa.inst里面。之后调用decode exec函数。具体来说，其核心代码是调用INSTPAT这个宏，宏里对每个instr的字符都进行了macro这个宏的处理。公有的mask和key的值根据不断调用的macro宏而发生变化，在最后将当前指令匹配到某一个现有的支持的指令上。确定了指令，还要确定operand，是通过decode_operand这个命令来根据指令的类型将operand提取出来保存在对应的位置，因为有的指令只有imm，rd，有的却有rd rs1 rs2，并且不同指令imm的编码方式也不同，所以需要定义rs1，rs2，不同类型指令imm的提取宏（函数），然后根据指令类型，分别调用对应的宏（函数）即可。提取完后的结果都存储在相应指针里，最后根据指令类型对相应的寄存器值或memory值执行相关的操作，进行更改即可。
执行完指令后，将dnpc赋值给pc。如果不是jump等语句，dnpc=snpc=pc+4，如果是的话，dnpc已经被更改为对应的目标地址。

这里有几个c语言的语法需要注意：
1. 在定义一个macro的时候，在每一行的末尾使用到了\，这是因为：macro的定义默认只在当前行。如果将macro拓展到很多行，需要使用\，可以理解为续行，认为这行没有结束。\一直到最后一行。这样写还有一个特点就是无法加//注释，这样后面的所有都被认为是注释。解决措施是用block comment /* */。
另外的方法就是#define SAFER_MACRO(x) do {  
    statement1;  
    statement2;  
} while(0)，将其套到do while(0)里。在nemu的代码中很多处都是这样。

1. 这里还涉及到了goto+labels的使用。goto finish和下面的finish：打配合，让代码跳转到某个地方。

2. #define是定义宏，但是#undef意思是取消定义。在这个函数里，只有2句语句被正常运行，macro64（0）和Panic，其余都是定义跳转等等。macro64之后马上就取消了定义，意思就是在这之后macro就没法再使用了，会被认为没定义这个macro。


在运行第一个C程序的时候我们要注意，不同的操作系统不同的CPU架构，其上所含的gcc是不同的。比如苹果就是Unix系统加arm架构，windows就是x86架构加windows系统。我们要编译一个测试代码，编译成riscv的指令集运行，则如果调用本机的gcc，会使得编译出来的是arm指令集。这时候需要交叉编译cross compile，
apt-get install g++-riscv64-linux-gnu binutils-riscv64-linux-gnu
g++-riscv64-linux-gnu意思就是riscv64指令集 Linux系统使用的gcc，编译出来的二进制就能直接用了。如果在做nemu的时候选择的是x86指令集架构，则windows机器本机的x86就可以生成可用的机器代码。
如果想使用GNU binutils来查看生成的bin或elf等文件，比如使用objdump和readelf工具，则需要使用交叉编译版本：需要使用相应的交叉编译版本, 如mips-linux-gnu-objdump, riscv64-linux-gnu-readelf等


如果指令没被定义，将会转到inv宏，这个宏里调用了invalid_inst函数，打印输出信息。

接下来开始添加新的指令到nemu中。在查阅手册的时候，有这些知识点：
unprivileged registers意思是运行在所有mode的命令都能access的regs。RISC-V有三种模式，machine mode supervisor mode和user mode，优先级逐层递减。unprivileged registers是运行在user mode都能获取到的寄存器。比如general purpose registers x0-x31.

手册p23有不同指令类型的instruction format,还有下面的immediate格式，图片的意思是对于一个32位的immediate，其各个位的数据都从32位指令的哪里取得。比如在I type immediate里面，前20位都取指令的最后一位的数（sign extend）。

在手册里，只是说了unprivileged regs有32个，第一个是0，并没有说这些寄存器分别用来干什么，这是由机器决定的。对于我们的nemu，执行指令的时候，指令里的寄存器也是以次序为标记的。所以我们需要先明确对于我们的nemu，寄存器和次序的关系：
"$0", "ra", "sp", "gp", "tp", "t0", "t1", "t2",
    "s0", "s1", "a0", "a1", "a2", "a3", "a4", "a5",
    "a6", "a7", "s2", "s3", "s4", "s5", "s6", "s7",
    "s8", "s9", "s10", "s11", "t3", "t4", "t5", "t6"


查看dummy-riscv32-nemu.txt可得这个程序需要用到的指令。注意machine code后面的注释有的是pseudo instruction，咱们只需要实现riscv32里面有的，不需要实现pseudo instruction。需要根据机器码来看这个指令到底在riscv manual里对应的是什么。
- p26页 addi。
- li是个pseudo-instruction，如果imm少于12位则li等效于一个addi。若其大于12位则li等效于lui+addi。这就是上文提到的32位immediate的处理方法。在dummy.c里，li指令其实就是addi，其指令代码为0x0000_0413。
- p28页jal。由于没有定义J type，我们先添加了J-Type这个类型，并为这个类型编写提取操作数的语句。提取操作数需要用到SEXT这个macro，意思是sign extend。jal本身有一个immediate和rd作为参数，其行为是将immediate+当前jal所在地址得到的值赋给PC，同时将PC+4赋给rd寄存器。这里注意，在取值完成后，我们已经将s->snpc变成了pc+4，所以赋值的时候需要让R(rd)=s->pc+4。
- 在dummy-riscv32-nemu.txt里的ret其实是jalr。翻译过来，意思是imm=0 rs1=1的jalr，意思是计算（rs1号寄存器的值的值）+imm，将其lsb赋为0，跳转到这个位置。并将rd寄存器的值赋为jalr地址+4。如果不需要记录返回值，就将rd设为x0。在这里，ret的机器码翻译过来，就是rd=0，imm=0，rs1=1，也就是跳转到ra这个寄存器里的地址处。ra的这个值恰恰是前面jal放进去的，所以这个语句是ret。
- sb和sw的区别：两者的格式都是sw rs2 imm(rs1)和sb rs2 imm(rs1)。地址的计算方法是相通的，rs1寄存器的值加imm。存储的东西不同，sw是存储整个rs2的32位数，而sb是只存储rs2 32位中的lsb。
- mv的意思是将一个reg的内容复制到另一个reg，是pseudo instruction，实现的时候用addi，将imm=0来实现。j是直接跳转，是pseudo instruction，实现的时候用jal，rd=\*0来实现。




summary: 已经支持并经过测试的指令有
- auipc
- addi
- jal
- lui
- sb
- sh
- sw
- lw
- lb
- lh
- lhu
- lbu
- jalr
- beq
- bne 
- blt 
- bge 
- bltu
- bgeu
- add
- sub
- slti
- sltiu
- slt
- sltu
- add
- or
- xor
- addi
- ori
- xori
- srai
- srli
- slli
- sll
- srl
- sra
- div
- divu
- mul
- rem
- remu
- mulh



接下来我完成了lw sw和lui。我打算测试一下。查阅资料得：auipc的意思是AUIPC (add upper immediate to pc) is used to build pc-relative addresses and uses the U-type format. AUIPC forms a 32-bit offset from the U-immediate, filling in the lowest 12 bits with zeros, adds this offset to the address of the AUIPC instruction, then places the result in register rd. 将auipc指令所在的地址和一个常数相加，将结果赋值给 destination register。


关于地址的部分，可以参考pa1知识点记录的init_isa()标题。
pmem在memory/paddr.c里面已经定义好，是个size为CONFIG_MSIZE的，类型为uint8_t的array。目前里面什么都没有。
在读取指令的时候，调用的是include/cpu/ifetch.h这个文件里定义的inst_fetch这个函数，是专门从memory读取命令的函数。里面调用的vaddr_ifetch这个函数，调用了paddr_read这个函数，里面调用了pmem_read。在这之前，所有的地方的argument对应的地址都是guest memory，类似于0x8000 0004这样的。在pmem_read里，首先调用了guest_to_host这个函数。这个函数接受一个guest memory，返回一个host memory。比如接受0x8000 0004，返回对应的本机上pmem对应元素的地址。这才真正完成了地址转换，之后调用host_read函数读取地址对应的元素。这个函数很简单，有一点值得一提的是，在传入参数的时候，由于不清楚你要读取的长度是多少，函数先让addr为void \*类型，接着有一个case语句，根据情况的不同赋给addr不同类型的指针。当addr的类型被处理好了，只需要return \*addr就可以读取对应长度的数据了。在return的后面跟着的是不同长度的数据，但是我们统一要word_t大小的数据，所以又做了个implicit type casting，这个时候默认从位数少的到位数多的默认是zero extend。我修改了一下这个函数，因为如果按照原始的样子，不管从内存读的是多长的数，都只能是zero extend。我多加了2个len的case，分别为-1和-2.对应生成SEXT的版本，这样就变成了sign extend。
这里引用一下函数的本体语句：
``` C
static inline word_t host_read(void *addr, int len) {
  switch (len) {
    case 1: return *(uint8_t  *)addr;
    case 2: return *(uint16_t *)addr;
    case 4: return *(uint32_t *)addr;
    IFDEF(CONFIG_ISA64, case 8: return *(uint64_t *)addr);
    case -1:
    return SEXT(*(uint8_t *)addr, 8);
    case -2:
    return SEXT(*(uint16_t *)addr, 16);
    default: MUXDEF(CONFIG_RT_CHECK, assert(0), return 0);
  }
}
```
所以，经过了层层包装，pmem_read最终接受guest memory和读取的字节长度len作为输入，返回guest memory处长度为len的数据。地址转换已经被抽象到底层无需care了。


这里可以多体会一下多层抽象的思想，如果换成我写，大概率就是用一个大函数叫read_mem，里面包含了所有的边界判断，更新pc等等操作。这里使用了多层抽象多层封装调用，每一层都有各自的目的。inst_ifetch是专门用来读取指令的函数，显然它除了读取以外还要先更新pc为pc+4。它调用的vaddr_ifetch除了调用paddr_read别的什么都没做，但是这是为了和取数据的函数进行区分。
``` C

word_t vaddr_ifetch(vaddr_t addr, int len) {
  return paddr_read(addr, len);
}

word_t vaddr_read(vaddr_t addr, int len) {
  return paddr_read(addr, len);
}
```
两个函数都是什么也没做只是调用了一个函数。所以理论上这两个函数都可以直接替换为paddr_read，但是为了区分应用场景，一个paddr_read是为了读取指令，另一个paddr_read是为了读取数据。可见为了让人读的舒服加了多少层抽象。在paddr_read里面，除了读内存，还做了边界判断，以免读的内存超过了内存的范围，在pmem_read内部，才是真正做了地址转换+读写内存的操作。所以可以看到，除了核心操作以外，每多做一件事情，就多套一层函数，方便管理。
这种思想还有很多，在nemu里，很多函数在多个文件里用不同的macro来表示，都只是为了在当前的文件里能以更readable的形式呈现出来。

经过复杂的测试，终于支持了dummy文件里的所有指令。运行之后的结果是good trap。

dummy经过测试之后，我尝试继续运行别的测试文件，在add里面涉及到了beq，我决定接下来实现beq bne blt bge bltu和bgeu。在尝试实现这些的时候，遇到了如下的问题：首先在所有的B类语句中都涉及到immediate。在这里首先我们要对immediate进行sign extend，之后由于branch语句要既能往前跳，也能往后跳，所以对于sign extend得到的结果应该以sword_t解读他。sword_t解读就是将其看成2's complement实现的数，有正负。但是在修改之后仍然出错，经过debug发现在immB里的移位逻辑出现错误。移位的位数一定考虑好当前抽取出的位数，再去看移多少位。以上2个bug修改完毕，add文件就能运行完成并且返回good trap了。

这里涉及到了一个新的需要考虑的地方就是我们在INSTPAT_MATCH这个宏里，src1和src2都是word_t类型的。说明在所有的指令的执行语句中都把src1和src2看成了unsigned去执行的。但是目前为止操作不涉及到比较，只有加法，load store，或者是对所含数据的直接操作，符号并不影响。在blt和bltu这两个的对比里就涉及到了这个差别。符号数和无符号数的比较不能一概而论。
我的一开始的想法是在INSTPAT_MATCH里多声明2个变量，这样的缺点就是在每个指令执行的时候都会多这2个变量，绝大多数情况根本用不上。后来的优化是在需要转化为 signed的语句的操作里在对应word_t类型的变量前面做type casting，即(sword_t)src1，这样就实现了局部的引用。

有个语法点可以学一下：在switch case里，如果case的是简单的数字，则非常不直观。解决方法是先创建一个enum变量，里面存储了case的东西，再case对应的enum entry即可。比如
``` C
enum
{
  TYPE_I,
  TYPE_U,
  TYPE_S,
  TYPE_N,
  TYPE_J,
  TYPE_B,
  TYPE_R // none
};
```
这样，case(TYPE_I)等就能直接看出这是I type instruction对应的语句。

接下来接着看下一个文件，add-longlong，这里涉及到了and xor or。注意，不管是在RISCV32指令集里还是在nemu里，and的操作都是&，即bitwise operator，而不是logical operator。

下一个文件 bit，里面涉及到srai，shift right arithmetic immediate。shift right分为2类，logical和arithmetic。前者将移出来的更高位设为0，后者将更高位用原数的符号位填充。在C语言里,>>这个运算符，当使用在signed上时进行arithmetic shift，当使用在unsigned shift时进行logical shift。所以在实现的时候，需要用type casting转变为sword_t。同时，slli srai srli三者虽然属于I类型，但是其改变了I类型原本的12位imm编码方式，用前7位作为opcode，imm只有五位，所以需要重新多一个type for 这种编码方式。同时在bit里还完成了lh sh等。

接下来完成了bubble-sort，crc32

RISCV32有M-extension，是对原本的RISCV32指令集的一个拓展。这里面是关于乘除法的一些指令。包括mul,mulh,mulhu,mulhsu,div,divu,rem,remu。注意没有mulu，原因涉及到了二进制乘法的一个特点：
32位乘32位，结果有可能大于32位。如果只取低32位的话，不管是当signed看还是unsigned看结果都一样。具体来说，在计算机内部，不管是unsigned还是signed都是当作一堆二进制来看的。二进制的乘法操作是不变的，所以不管你怎么解读operand和result，最终得到的结果都是一样的。而mult命令本身就是将结果的低32位赋给rd寄存器，所以不管做的是什么乘法，低32位对应的二进制都是一样的。但是高32位就不同了。事实上假如32位a和32位b相乘，结果是35位，则将结果解读为signed或unsigned差别就在于第36位再高的位置。如果是signed就会自动变成sign extend否则就是0 extend。所以，如果只想取最低位，mul就可以。如果想取高32位就分成了mulh和mulhu。
实现mulh的时候，也要注意，要想如果直接word_t乘word_t，得到的结果也是word_t，32位。如果要想获得高64位，必须先将operand转化为64位，变成(int64_t)(sword_t)src1，将得到的结果 >> 32，再转变为32位的word_t就可以了。从64位转变为32位默认取低32位。

在实现div的时候，需要排查几个特殊的情况：首先，如果除以0，会将-1当作结果赋值给结果寄存器。其次，由于用补码来描述一个数，负数的范围比正数大一。所以如果用最小的负数除以-1，得到的正数是无法正常表示的，这种情况下会返回INT32_MIN。

上面记录的已经实现的代码有可能有遗漏，但是到目前为止，除了讲义提到的hello-str和string2个程序以外，其余程序均已经过了正确的测试，结果是hit good trap。

讲义中提到了分支延迟槽delay slot，这是MIPS32中提到的一种和流水线配合提高效率的方法。具体来说，现代处理器全部是流水线，同时有很多个指令一起在运行。在顺序执行的情况下，直接接着读下一个，接着流水线就行。但是如果有分支语句，其后的指令到底是哪个就要看分支的判断结果。但是如果等待分支结果出来再读取，就会导致一整个周期空白，这叫bubble。现代处理器会使用分支预测的方法提前填充指令。delay slot也是个减少bubble的方法。具体来说，他会有一个检查范围，当有分支语句的时候，会在检查范围里查找指令，which 不受到顺序和其他指令结果的影响，不依赖其余的命令。这样的指令在哪里执行都可以，并且一定会执行。所以就将这样的指令放在branch语句后面。
100: beq 200
101: add
102: xor
...
200: sub
201: j   102
202: slt

若beq指令的执行结果为跳转, 则相应的动态指令流为100 -> 101 -> 200; 若beq指令的执行结果为不跳转, 则相应的动态指令流为100 -> 101 -> 102; 而对于j指令, 相应的动态指令流为201 -> 202 -> 102.
# 程序，运行时环境与AM
程序的运行需要运行时系统的支持。运行时系统，又叫runtime system，是每个编程语言都具有的一个帮助程序正常运行的系统。在nemu里，最简单的运行时系统做的事情就是：只要把程序放在正确的内存位置, 然后让PC指向第一条指令, 计算机就会自动执行这个程序, 永不停止，知道提供了结束的语句。更复杂的情况包括stack heap的管理，IO的管理等等。
运行时环境的一种普遍的存在方式: 库. 通过库, 运行程序所需要的公共要素被抽象成API, 不同的架构只需要实现这些API, 也就相当于实现了支撑程序运行的运行时环境, 这提升了程序开发的效率: 需要的时候只要调用这些API, 就能使用运行时环境提供的相应功能。
更具体的，这些API代表了程序运行对于计算机的需求。因为计算机的cpu架构不同，所以不同的架构对于同一个API的实现方法也不同。但是，每个架构只需要维护好API的具体实现方法，不同的程序需要这个需求，就调用这个API即可。所有的需求的汇总，也就是API的汇总，在这里被称为抽象计算机abstract machine。
AM可以分为这些个部分：
AM = TRM + IOE + CTE + VME + MPE
TRM(Turing Machine) - 图灵机, 最简单的运行时环境, 为程序提供基本的计算能力
IOE(I/O Extension) - 输入输出扩展, 为程序提供输出输入的能力
CTE(Context Extension) - 上下文扩展, 为程序提供上下文管理的能力
VME(Virtual Memory Extension) - 虚存扩展, 为程序提供虚存管理的能力
MPE(Multi-Processor Extension) - 多处理器扩展, 为程序提供多处理器通信的能力 (MPE超出了ICS课程的范围, 在PA中不会涉及).


volatile关键字，用于可能会在程序外突然改变的变量上：
``` C
volatile int sensor_reading;

int main() {
    // The compiler won't optimize access to sensor_reading
    while (sensor_reading < 100) {
        // Keep waiting
    }
    printf("Sensor reading reached: %d\n", sensor_reading);
    return 0;
}
```
这段程序为例，sensor_reading前面有volatile。如果没有volatile，编译器在编译的时候，每次循环都是判断sensor_reading，编译器知道语句之间没有直接改变该变量的代码，所以编译器就会在下次循环使用上次的数值，所以这就是个永远循环。如果有volatile关键字，compiler每次判断，都从内存里重新读取而不是想当然的做optimization。
这个关键字适用于外接设备IO等等情况，在代码里不会变化，由外界的变化而变化的情况。


inline assembly，内联汇编，是一种在C语言中运行汇编语言的方法，格式如下：
``` C
asm [volatile] ("assembly instructions"
               : output operands
               : input operands
               : clobbered registers);
               
```

汇编语言的指令需要指定输入寄存器和输出寄存器。在这里的output operands和input operands就是用来指定输入输出的变量和存放的寄存器之间的关系。
比如
``` C
int add_numbers(int a, int b) {
    int result;
    asm("add %0, %1, %2"    // Assembly instruction
        : "=r"(result)      // Output: result goes into any register (=r)
        : "r"(a), "r"(b)    // Inputs: a and b from any registers
        );
    return result;
}
```
汇编指令是add。
The constraint characters (like "r", "=r", etc.) tell the compiler how to handle variables. Here are the most common ones:

"r": Any general-purpose register
"=r": Output to any general-purpose register
"m": Memory location
"i": Immediate constant
"g": Any register, memory, or immediate constant

前面的0%等都是placeholder占位符。所以这段代码的意思就是输入取的值是a和b，这个值来自于你的C程序。汇编语言要想使用值先要存储在寄存器里，这里的"r"意思就是输入a和b存储在任何一个可用的寄存器都可以。输出的"=r"意思也是同理，不过是给输出用的。(result)意思是将输出的值赋给result这个C语言变量。最后一个clobbered registers意思是汇编语言要使用到的寄存器。如果没有这个关键字，compiler可能将结果overwrite到这些寄存器上，使得本来要用到的数据丢失了。clobbered regs可能还会包含memory这个关键字。当汇编语言要往内存里读或写的时候，就要有memory这个关键字。

最safe的写法是将所有hard code的寄存器全部列出来，且一旦有可能涉及到内存读写就写上memory。
下面给出一个例子：

``` C
void memory_clobber_example(void) {
    int array[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int sum = 0;
    
    // This assembly code sums array elements
    asm volatile(
        "li     t0, 0          \n\t"  // counter = 0
        "li     t1, 0          \n\t"  // sum = 0
        "li     t2, 10         \n\t"  // limit = 10
        "1:                    \n\t"  // loop start
        "bge    t0, t2, 2f     \n\t"  // if counter >= 10, exit
        "slli   t3, t0, 2      \n\t"  // t3 = counter * 4 (word offset)
        "add    t3, %1, t3     \n\t"  // t3 = base + offset
        "lw     t4, 0(t3)      \n\t"  // load array[counter]
        "add    t1, t1, t4     \n\t"  // sum += array[counter]
        "addi   t0, t0, 1      \n\t"  // counter++
        "j      1b             \n\t"  // loop back
        "2:                    \n\t"  // loop end
        "mv     %0, t1"               // store sum to output
        
        : "=r"(sum)
        : "r"(array)
        : "t0", "t1", "t2", "t3", "t4", "memory"
        //                           ^^^^^^^^
        // This tells the compiler that we might read/write
        // any memory location. Without this, the compiler
        // might optimize away array initialization or
        // assume array values haven't changed!
    );
    
    printf("Sum: %d\n", sum);
}
```
